/* eslint-disable max-depth */
/* eslint-disable no-sync */
/* eslint-disable camelcase */
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// create interfaces.d.ts containing from each typeclass definition
/* Example output for std_msgs_msg_String
declare module "rclnodejs" {
  namespace std_msgs {
	  namespace msg {
			export type String = {
				data: string
			}
		}
	}
}
*/

'use strict';

const path = require('path');
const fs = require('fs');
const loader = require('../lib/interface_loader.js');

function generateAll() {
  // load pkg and interface info (msgs and srvs)
  const generatedPath = path.join(__dirname, '../generated/');
  const pkgInfos = getPkgInfos(generatedPath);

  // write message.d.ts file
  const messagesFilePath = path.join(__dirname, '../types/interfaces.d.ts');
  const fd = fs.openSync(messagesFilePath, 'w');
  savePkgInfoAsTSD(pkgInfos, fd);
}

// scan generated files, collect pkg and msg info
function getPkgInfos(generatedRoot) {
  let pkgInfos = [];
  const rootDir = generatedRoot;
  let pkgs = fs.readdirSync(rootDir);

  for (let pkg of pkgs) {
    if (pkg.endsWith('.json')) continue;

    const pkgInfo = {
      name: pkg,
      messages: [],
      services: [],
      actions: [],
    };

    const pkgPath = path.join(rootDir, pkg);
    const files = fs.readdirSync(pkgPath).filter(fn => fn.endsWith('.js'));

    for (let filename of files) {
      const typeClass = fileName2Typeclass(filename);

      if (typeClass.type && typeClass.type.startsWith('srv')) {
        // skip __srv__<action>
        if (
          !typeClass.name.endsWith('_Request') &&
          !typeClass.name.endsWith('_Response')
        ) {
          pkgInfo.services.push(typeClass);
          continue;
        }
      }

      const msg = createMessage(typeClass);
      const type = msg.constructor.type();
      const def = msg.constructor.ROSMessageDef;
      const name =
        (def && def.msgName) ||
        `${typeClass.package}_${typeClass.type}_${typeClass.name}`;

      const msgInfo = {
        name: name,
        typeClass: typeClass,
        type: type,
        def: def,
      };

      if (typeClass.type && typeClass.type.startsWith('action')) {
        pkgInfo.actions.push(msgInfo);
      } else {
        pkgInfo.messages.push(msgInfo);
      }
    }

    pkgInfos.push(pkgInfo);
  }

  return pkgInfos;
}

function savePkgInfoAsTSD(pkgInfos, fd) {
  let messagesMap = {
    string: 'string',
  };
  const actionsMap = {};

  fs.writeSync(fd, '/* eslint-disable camelcase */\n');
  fs.writeSync(fd, '/* eslint-disable max-len */\n');
  fs.writeSync(fd, '// DO NOT EDIT\n');
  fs.writeSync(fd, '// This file is generated by the rostsd_gen script\n\n');

  const moduleDeclare = "declare module 'rclnodejs' {\n";
  fs.writeSync(fd, moduleDeclare);

  for (const pkgInfo of pkgInfos) {
    // write namespaces heirarchy for package
    const pkgNamespaceTemplate = `  namespace ${pkgInfo.name} {
`;
    fs.writeSync(fd, pkgNamespaceTemplate);

    let curNS = null;
    for (const msgInfo of pkgInfo.messages) {
      if (msgInfo.typeClass.type != curNS) {
        if (curNS) {
          // close current ns
          fs.writeSync(fd, '    }\n');
        }

        curNS = msgInfo.typeClass.type;

        // write namespaces heirarchy for package
        const msgNamespaceTemplate = `    namespace ${curNS} {
`;
        fs.writeSync(fd, msgNamespaceTemplate);
      }

      saveMsgInfoAsTSD(msgInfo, fd);
      saveMsgConstructorAsTSD(msgInfo, fd);

      // full path to this msg
      const fullMessageName = `${pkgInfo.name}/${msgInfo.typeClass.type}/${msgInfo.typeClass.name}`;
      messagesMap[
        fullMessageName
      ] = `${pkgInfo.name}.${msgInfo.typeClass.type}.${msgInfo.typeClass.name}`;
    }

    if (curNS) {
      // close msg level namespace declare
      fs.writeSync(fd, '    }\n');
    }

    if (pkgInfo.actions.length > 0) {
      fs.writeSync(fd, '    namespace action {\n');
      for (const msgInfo of pkgInfo.actions) {
        const fullMessageName = `${pkgInfo.name}/${msgInfo.typeClass.type}/${msgInfo.typeClass.name}`;
        const fullMessagePath = `${pkgInfo.name}.${msgInfo.typeClass.type}.${msgInfo.typeClass.name}`;

        if (isActionMsgInterface(msgInfo.name)) {
          saveActionMsgInfoAsTSD(msgInfo, fd);
          saveMsgConstructorAsTSD(msgInfo, fd);

          // full path to this msg
          messagesMap[fullMessageName] = fullMessagePath;
        } else if (isActionSrvInterface(msgInfo.name)) {
          saveActionSrvInfoAsTSD(msgInfo, fd);
        } else {
          saveActionInfoAsTSD(msgInfo, fd);

          actionsMap[fullMessageName] = fullMessagePath + 'Constructor';
        }
      }

      // close action level namespace declare
      fs.writeSync(fd, '    }\n');
    }

    // close pkg level namespace declare
    fs.writeSync(fd, '  }\n\n');
  }

  // write messages type mappings
  fs.writeSync(fd, '  type MessagesMap = {\n');
  for (const key in messagesMap) {
    fs.writeSync(fd, `    '${key}': ${messagesMap[key]},\n`);
  }
  fs.writeSync(fd, '  };\n');
  fs.writeSync(fd, '  type MessageTypeClassName = keyof MessagesMap;\n');
  fs.writeSync(fd, '  type Message = MessagesMap[MessageTypeClassName];\n');
  fs.writeSync(
    fd,
    '  type MessageType<T> = T extends MessageTypeClassName ? MessagesMap[T] : object;\n\n'
  );

  // write message contructor mappings
  fs.writeSync(fd, '  type MessageTypeClassConstructorMap = {\n');
  for (const key in messagesMap) {
    if (key === 'string') {
      fs.writeSync(fd, "    'string': never,\n");
      continue;
    }
    fs.writeSync(fd, `    '${key}': ${messagesMap[key]}Constructor,\n`);
  }
  fs.writeSync(fd, '  };\n');
  fs.writeSync(
    fd,
    '  type MessageConstructorType<T> = ' +
      'T extends MessageTypeClassName ? MessageTypeClassConstructorMap[T] : object;\n\n'
  );

  // write service type class string
  const services = [];
  for (const pkg of pkgInfos) {
    services.push(...pkg.services);
  }
  if (!services.length) {
    fs.writeSync(fd, '  type ServiceTypeClassName = never;\n\n');
  } else {
    fs.writeSync(fd, '  type ServiceTypeClassName = \n');
    for (let i = 0; i < services.length; i++) {
      const srv = services[i];
      const srvTypeClassStr = `${srv.package}/${srv.type}/${srv.name}`;
      fs.writeSync(fd, `    '${srvTypeClassStr}'`);

      if (i !== services.length - 1) {
        fs.writeSync(fd, ' |\n');
      }
    }
    fs.writeSync(fd, ';\n\n');
  }

  // write actions type mappings
  fs.writeSync(fd, '  type ActionsMap = {\n');
  for (const key in actionsMap) {
    fs.writeSync(fd, `    '${key}': ${actionsMap[key]},\n`);
  }
  fs.writeSync(fd, '  };\n');
  fs.writeSync(fd, '  type ActionTypeClassName = keyof ActionsMap;\n');
  fs.writeSync(fd, '  type Action = ActionsMap[ActionTypeClassName];\n');
  fs.writeSync(
    fd,
    '  type ActionType<T> = T extends ActionTypeClassName ? ActionsMap[T] : object;\n\n'
  );

  fs.writeSync(
    fd,
    '  type TypeClassName = MessageTypeClassName | ServiceTypeClassName | ActionTypeClassName;\n'
  );
  fs.writeSync(
    fd,
    '  type InterfaceType<T> = T extends MessageTypeClassName | ActionTypeClassName ? ' +
      '(MessageTypeClassConstructorMap & ActionsMap)[T] : object;\n'
  );

  // close module declare
  fs.writeSync(fd, '}\n');

  fs.closeSync(fd);
}

function saveMsgConstructorAsTSD(msgInfo, fd) {
  const msgName = msgInfo.typeClass.name;
  fs.writeSync(fd, `      export interface ${msgName}Constructor {\n`);
  for (const constant of msgInfo.def.constants) {
    const constantType = primitiveType2JSName(constant.type);
    fs.writeSync(fd, `        readonly ${constant.name}: ${constantType};\n`);
  }
  fs.writeSync(fd, `        new(other?: ${msgName}): ${msgName};\n`);
  fs.writeSync(fd, '      }\n');
}

/**
 * Writes the message fields as typescript definitions.
 *
 * @param {*} msgInfo ros message info
 * @param {*} fd file descriptor
 * @param {string} indent The amount of indent, in spaces
 * @param {string} lineEnd The character to put at the end of each line, usually ','
 * or ';'
 * @param {string} typePrefix The prefix to put before the type name for
 * non-primitive types
 * @param {boolean} useSamePackageSubFolder Indicates if the sub folder name should be taken from the message
 * when the field type comes from the same package. This is needed for action interfaces. Defaults to false.
 * @returns {undefined}
 */
function saveMsgFieldsAsTSD(
  msgInfo,
  fd,
  indent = 0,
  lineEnd = ',',
  typePrefix = '',
  useSamePackageSubFolder = false
) {
  for (let i = 0; i < msgInfo.def.fields.length; i++) {
    const field = msgInfo.def.fields[i];

    let subFolder = 'msg';
    if (
      useSamePackageSubFolder &&
      field.type.pkgName === msgInfo.type.pkgName
    ) {
      subFolder = msgInfo.type.subFolder;
    }

    let fieldType = fieldType2JSName(field, subFolder);
    let tp = field.type.isPrimitiveType ? '' : typePrefix;
    if (typePrefix === 'rclnodejs.') {
      fieldType = 'any';
      tp = '';
    }
    
    const tmpl = indentString(`${field.name}: ${tp}${fieldType}`, indent);
    fs.writeSync(fd, tmpl);
    if (field.type.isArray) {
      fs.writeSync(fd, '[]');
     
      if (fieldType === 'number') {
        // for number[] include alternate typed-array types, e.g., number[] | uint8[]
        let jsTypedArrayName = 
          fieldTypeArray2JSTypedArrayName(field.type.type);

        if (jsTypedArrayName) {
          fs.writeSync(fd, ` | ${jsTypedArrayName}`);
        }
      }
    }

    fs.writeSync(fd, lineEnd);
    fs.writeSync(fd, '\n');
  }
}

function saveMsgInfoAsTSD(msgInfo, fd) {
  // write interface xxxx {
  const typeTemplate = `      export interface ${msgInfo.typeClass.name} {\n`;

  fs.writeSync(fd, typeTemplate);

  // write field definitions
  saveMsgFieldsAsTSD(msgInfo, fd, 8, ';');

  // end of def
  fs.writeSync(fd, '      }\n');
}

function saveActionMsgInfoAsTSD(msgInfo, fd) {
  // write interface xxxx {
  const typeTemplate = `      export interface ${msgInfo.typeClass.name} {\n`;

  fs.writeSync(fd, typeTemplate);

  const userDefinedMsg = isUserDefinedActionMsgInterface(msgInfo.name);

  // write field definitions
  saveMsgFieldsAsTSD(msgInfo, fd, 8, ';', '', !userDefinedMsg);

  // end of def
  fs.writeSync(fd, '      }\n');
}

function saveActionSrvInfoAsTSD(msgInfo, fd) {
  const actionSrv = msgInfo.typeClass.name;

  const interfaceTemplate = [
    `export interface ${actionSrv}Constructor {`,
    `  readonly Request: ${actionSrv}_RequestConstructor;`,
    `  readonly Response: ${actionSrv}_ResponseConstructor;`,
    '}',
    '',
  ];

  fs.writeSync(fd, indentLines(interfaceTemplate, 6).join('\n'));
}

function saveActionInfoAsTSD(msgInfo, fd) {
  const action = msgInfo.typeClass.name;

  const interfaceTemplate = [
    `export interface ${action}Constructor {`,
    `  readonly Goal: ${action}_GoalConstructor;`,
    `  readonly Result: ${action}_ResultConstructor;`,
    `  readonly Feedback: ${action}_FeedbackConstructor;`,
    '}',
    '',
  ];

  fs.writeSync(fd, indentLines(interfaceTemplate, 6).join('\n'));
}

function fieldType2JSName(fieldInfo, subFolder = 'msg') {
  return fieldInfo.type.isPrimitiveType
    ? primitiveType2JSName(fieldInfo.type.type)
    : `${fieldInfo.type.pkgName}.${subFolder}.${fieldInfo.type.type}`;
}

// https://design.ros2.org/articles/idl_interface_definition.html
// https://github.com/ros2/rosidl/blob/master/rosidl_parser/rosidl_parser/definition.py
function primitiveType2JSName(type) {
  let jsName;

  switch (type) {
    case 'char':
    case 'byte':
    case 'octet':

    // signed explicit integer types
    case 'short':
    case 'long':
    case 'long long':

    // unsigned nonexplicit integer types
    case 'unsigned short':
    case 'unsigned long':
    case 'unsigned long long':

    // float point types
    case 'float':
    case 'double':
    case 'long double':

    // signed explicit integer types
    case 'int8':
    case 'int16':
    case 'int32':
    case 'int64':
    
    // signed explicit float types
    case 'float32':
    case 'float64':

    // unsigned explicit integer types
    case 'uint8':
    case 'uint16':
    case 'uint32':
    case 'uint64':
      jsName = 'number';
      break;
    case 'bool': 
    case 'boolean':
      jsName = 'boolean';
      break;
    case 'string':
    case 'wstring':
      jsName = 'string';
      break;
  }

  return jsName;
}

function fieldTypeArray2JSTypedArrayName(type) {
  let jsName;

  switch (type) {
    case 'byte':
    case 'octet':
    case 'uint8':
      jsName = 'Uint8Array';
      break;
    case 'char':
    case 'int8':
      jsName = 'Int8Array';
      break;
    case 'int16':
    case 'short':
      jsName = 'Int16Array';
      break;
    case 'uint16':
    case 'unsigned short':
      jsName = 'Uint16Array';
      break;
    case 'int32':
    case 'long':
      jsName = 'Int32Array';
      break;
    case 'uint32':
    case 'unsigned long':
      jsName = 'Uint32Array';
      break;
    case 'float':
    case 'float32':
      jsName = 'Float32Array';
      break;
    case 'double':
    case 'float64':
      jsName = 'Float64Array';
      break;
    
    case 'long long':
    case 'unsigned long long':
    case 'int64':
    case 'uint64':
      // number 
      break;
  }

  return jsName;
}

// example filename: std_msgs_msg_String, sensor_msgs_msg_LaserScan
// result {package: 'std_msgs', type: 'msg', name: 'String'}
function fileName2Typeclass(filename) {
  const regex = /(.+)__(\w+)__(\w+)\.js/;
  const array = filename.split(regex).filter(Boolean);

  if (!array || array.length != 3) {
    // todo: throw error
    console.log('ERRORRROOROR', array);
    return;
  }

  return {
    package: array[0],
    type: array[1],
    name: array[2],
  };
}

function createMessage(type) {
  let typeClass = loader.loadInterface(type);
  return typeClass ? new typeClass() : undefined;
}

function isActionMsgInterface(name) {
  return (
    name.endsWith('_FeedbackMessage') ||
    name.endsWith('_Request') ||
    name.endsWith('_Response') ||
    isUserDefinedActionMsgInterface(name)
  );
}

function isUserDefinedActionMsgInterface(name) {
  return (
    name.endsWith('_Feedback') ||
    name.endsWith('_Goal') ||
    name.endsWith('_Result')
  );
}

function isActionSrvInterface(name) {
  return name.endsWith('_GetResult') || name.endsWith('_SendGoal');
}

function indentString(string, amount) {
  if (!string) {
    return '';
  }

  return ' '.repeat(amount) + string;
}

function indentLines(lines, amount) {
  if (!Array.isArray(lines)) {
    throw new Error('lines must be an array');
  }

  return lines.map(line => indentString(line, amount));
}

const tsdGenerator = {
  generateAll,
};

module.exports = tsdGenerator;
