// This file is automatically generated by rclnodejs
//
// *** DO NOT EDIT directly
//

#include "definitions.hpp"
#include "../../type_conversion.hpp"

{{~ it.dependentMessages : messageInfo}}
#include "../{{=messageInfo.pkgName}}/definitions.hpp"
{{~}}

{{~ it.messages : message}}
#include <{{=it.getRosHeaderField(message.info)}}>
{{~}}
{{~ it.dependentMessages : messageInfo}}
struct {{=it.getStructType(messageInfo)}};
{{~}}

namespace rclnodejs {

{{~ it.messages : message}}
NAN_MODULE_INIT(rclnodejs__{{=message.structType}}::Init) {
  auto obj = Nan::New<v8::Object>();
  obj->Set(Nan::New("create").ToLocalChecked(), Nan::New<v8::Function>(rclnodejs__{{=message.structType}}::Create));
  obj->Set(Nan::New("from").ToLocalChecked(), Nan::New<v8::Function>(rclnodejs__{{=message.structType}}::FromJsObject));
  obj->Set(Nan::New("to").ToLocalChecked(), Nan::New<v8::Function>(rclnodejs__{{=message.structType}}::ToJsObject));
  Nan::Set(target, Nan::New("{{=message.info.interfaceName}}").ToLocalChecked(), obj);
}

void rclnodejs__{{=message.structType}}::WriteMessage(v8::Local<v8::Object> jsObj, {{=message.structType}}* msg) {
{{~ message.spec.fields : field}}
{{? !it.isInternalField(field)}}
  {
    // end with underscore so it doesn't conflicts with field names
    auto js_value_ = jsObj->Get(Nan::New("{{=field.name}}").ToLocalChecked());
{{
    const jsType = it.getJsType(field.type);
}}
{{? jsType === 'number'}}
    if (!js_value_->IsNumber()) {
      throw new std::runtime_error("expected {{=field.name}} to be number");
    }
{{?? jsType === 'string'}}
    if (!js_value_->IsString()) {
      throw new std::runtime_error("expected {{=field.name}} to be string");
    }
{{?? jsType === 'boolean'}}
    if (!js_value_->IsBoolean()) {
      throw new std::runtime_error("expected {{=field.name}} to be boolean");
    }
{{?? jsType === 'bigint'}}
    if (!js_value_->IsBigInt()) {
      throw new std::runtime_error("expected {{=field.name}} to be bigint");
    }
{{??}}
    if (!js_value_->IsObject()) {
      throw new std::runtime_error("expected {{=field.name}} to be {{=field.type.type}} object");
    }
{{?}}
{{? !field.type.isArray}}
{{? field.type.isPrimitiveType}}
    msg->{{=field.name}} = ToNativeChecked<decltype(msg->{{=field.name}})>(js_value_);
{{??}}
    rclnodejs__{{=it.getStructTypeFromRosType(field.type)}}::WriteMessage(Nan::To<v8::Object>(js_value_).ToLocalChecked(), &msg->{{=field.name}});
{{?}}
{{??}}
    // TODO: handle array types
{{?}}
  }
{{?}}
{{~}}
}

v8::Local<v8::Object> rclnodejs__{{=message.structType}}::MakeJsObject({{=message.structType}}* msg) {
  auto jsObj = Nan::New<v8::Object>();
{{~ message.spec.fields : field}}
{{? !it.isInternalField(field)}}
{{? !field.type.isArray}}
{{? field.type.isPrimitiveType}}
  jsObj->Set(Nan::New("{{=field.name}}").ToLocalChecked(), ToJsChecked(msg->{{=field.name}}));
{{??}}
  jsObj->Set(Nan::New("{{=field.name}}").ToLocalChecked(), rclnodejs__{{=it.getStructTypeFromRosType(field.type)}}::MakeJsObject(&msg->{{=field.name}}));
{{?}}
{{??}}
  // TODO: handle array
{{?}}
{{?}}
{{~}}
  return jsObj;
}

NAN_METHOD(rclnodejs__{{=message.structType}}::Create) {
  auto* data = {{=message.structType}}__create();
  auto buffer = Nan::NewBuffer(reinterpret_cast<char*>(data), sizeof(*data), [](auto* data, auto) {
    {{=message.structType}}__destroy(reinterpret_cast<{{=message.structType}}*>(data));
  }, nullptr).ToLocalChecked();
  info.GetReturnValue().Set(buffer);
}

NAN_METHOD(rclnodejs__{{=message.structType}}::FromJsObject) {
  auto jsObj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
  auto* msg = {{=message.structType}}__create();

  try {
    rclnodejs__{{=message.structType}}::WriteMessage(jsObj, msg);
  } catch (const std::runtime_error& e) {
    Nan::ThrowError(Nan::New(e.what()).ToLocalChecked());
    info.GetReturnValue().Set(Nan::Undefined());
    return;
  }

  auto buffer = Nan::NewBuffer(reinterpret_cast<char*>(msg), sizeof(*msg), [](auto* msg, auto) {
    {{=message.structType}}__destroy(reinterpret_cast<{{=message.structType}}*>(msg));
  }, nullptr).ToLocalChecked();
  info.GetReturnValue().Set(buffer);
}

NAN_METHOD(rclnodejs__{{=message.structType}}::ToJsObject) {
  auto* buffer = node::Buffer::Data(info[0]);
  auto* msg = reinterpret_cast<{{=message.structType}}*>(buffer);
  info.GetReturnValue().Set(rclnodejs__{{=message.structType}}::MakeJsObject(msg));
}

{{~}}

NAN_MODULE_WORKER_ENABLED({{=it.pkgName}}, [](auto target) {
{{~ it.messages : message}}
  rclnodejs__{{=message.structType}}::Init(target);
{{~}}
});

} // namespace rclnodejs
