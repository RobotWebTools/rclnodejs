// This file is automatically generated by rclnodejs
//
// *** DO NOT EDIT directly
//

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"

#include "definitions.hpp"
#include "../../type_conversion.hpp"

{{~ it.includeHeaders : header}}
#include <{{=header}}>
{{~}}

namespace rclnodejs {

{{~ it.messages : message}}
NAN_MODULE_INIT(rclnodejs__{{=message.structType}}::Init) {
  auto clazz = Nan::New<v8::FunctionTemplate>();
  clazz->SetClassName(Nan::New("{{=message.info.interfaceName}}").ToLocalChecked());
  clazz->Set(Nan::New("createRosMessage").ToLocalChecked(), Nan::New<v8::FunctionTemplate>(rclnodejs__{{=message.structType}}::CreateRosMessage));
  clazz->Set(Nan::New("writeRosMessage").ToLocalChecked(), Nan::New<v8::FunctionTemplate>(rclnodejs__{{=message.structType}}::WriteRosMessage));
  clazz->Set(Nan::New("toJsObject").ToLocalChecked(), Nan::New<v8::FunctionTemplate>(rclnodejs__{{=message.structType}}::ToJsObject));
  clazz->Set(Nan::New("initSequence").ToLocalChecked(), Nan::New<v8::FunctionTemplate>(rclnodejs__{{=message.structType}}::InitSequence));
  Nan::Set(target, Nan::New("{{=message.info.interfaceName}}").ToLocalChecked(), Nan::GetFunction(clazz).ToLocalChecked());
}

NAN_METHOD(rclnodejs__{{=message.structType}}::CreateRosMessage) {
  auto* data = {{=message.structType}}__create();
  auto buffer = Nan::NewBuffer(reinterpret_cast<char*>(data), sizeof(*data), [](auto* data, auto) {
    {{=message.structType}}__destroy(reinterpret_cast<{{=message.structType}}*>(data));
  }, nullptr).ToLocalChecked();
  info.GetReturnValue().Set(buffer);
}

NAN_METHOD(rclnodejs__{{=message.structType}}::WriteRosMessage) {
  auto typesupport = Nan::To<v8::Object>(info[0]).ToLocalChecked();
  auto js_obj = Nan::To<v8::Object>(info[1]).ToLocalChecked();
  {{=message.structType}}* msg;
  if (info[2]->IsExternal()) {
    msg = reinterpret_cast<{{=message.structType}}*>(info[2].As<v8::External>()->Value());
  } else {
    auto* data = node::Buffer::Data(info[2]);
    auto offset = info[2].As<v8::Uint8Array>()->ByteOffset();
    msg = reinterpret_cast<{{=message.structType}}*>(data + offset);
  }

{{~ message.spec.fields : field}}
{{? !it.isInternalField(field)}}
  [&](){
    auto js_value = Nan::Get(js_obj, Nan::New("{{=field.name}}").ToLocalChecked()).ToLocalChecked();
    if (js_value->IsNullOrUndefined()) {
      // default value is initialized when message is created.
      return;
    }
{{
const jsType = it.getJsType(field.type);
}}
{{? !field.type.isArray}}
{{? field.type.isPrimitiveType}}
    msg->{{=field.name}} = ToNativeChecked<decltype(msg->{{=field.name}})>(js_value);
{{??}}
    auto typesupport_msg = Nan::To<v8::Object>(Nan::Get(typesupport, Nan::New("{{=field.type.pkgName}}/{{=field.type.type}}").ToLocalChecked()).ToLocalChecked()).ToLocalChecked();
    auto typesupport_func = Nan::To<v8::Function>(Nan::Get(typesupport_msg, Nan::New("_writeRosMessage").ToLocalChecked()).ToLocalChecked()).ToLocalChecked();
    v8::Local<v8::Value> argv[] = {
      js_value,
      Nan::New<v8::External>(&msg->{{=field.name}})
    };
    Nan::Call(typesupport_func, Nan::New<v8::Object>(), 2, argv).ToLocalChecked();
{{?}}
{{??}}
{{? field.type.isFixedSizeArray}}
{{? field.type.isPrimitiveType}}
    WriteNativeArray<std::decay_t<decltype(*msg->{{=field.name}})>>(js_value, msg->{{=field.name}}, {{=field.type.arraySize}});
{{??}}
    auto typesupport_msg = Nan::To<v8::Object>(Nan::Get(typesupport, Nan::New("{{=field.type.pkgName}}/{{=field.type.type}}").ToLocalChecked()).ToLocalChecked()).ToLocalChecked();
    WriteNativeObjectArray<std::decay_t<decltype(*msg->{{=field.name}})>>(js_value, msg->{{=field.name}}, {{=field.type.arraySize}}, typesupport_msg);
{{?}}
{{??}}
{{? field.type.arraySize === null}}
    size_t capacity = 0xffffffffffffffff;
{{??}}
    size_t capacity = {{=field.type.arraySize}};
{{?}}
{{? field.type.isPrimitiveType}}
    WriteNativeSequence<std::decay_t<decltype(msg->{{=field.name}})>>(js_value, &msg->{{=field.name}}, capacity);
{{??}}
    auto typesupport_msg = Nan::To<v8::Object>(Nan::Get(typesupport, Nan::New("{{=field.type.pkgName}}/{{=field.type.type}}").ToLocalChecked()).ToLocalChecked()).ToLocalChecked();
    WriteNativeObjectSequence<std::decay_t<decltype(msg->{{=field.name}})>>(js_value, &msg->{{=field.name}}, capacity, typesupport_msg);
{{?}}
{{?}}
{{?}}
  }();
{{?}}
{{~}}
}

NAN_METHOD(rclnodejs__{{=message.structType}}::ToJsObject) {
  auto typesupport = Nan::To<v8::Object>(info[0]).ToLocalChecked();
  auto buffer = info[1].As<v8::Uint8Array>()->Buffer();
  auto* data = reinterpret_cast<char*>(buffer->GetContents().Data());
  auto offset = info[1].As<v8::Uint8Array>()->ByteOffset();
  auto* msg = reinterpret_cast<{{=message.structType}}*>(data + offset);

  auto js_obj = Nan::New<v8::Object>();
{{~ message.spec.fields : field}}
{{? !it.isInternalField(field)}}
  {
{{? !field.type.isArray}}
{{? field.type.isPrimitiveType}}
    Nan::Set(js_obj, Nan::New("{{=field.name}}").ToLocalChecked(), ToJsChecked(msg->{{=field.name}}));
{{??}}
    auto child_buffer = v8::Uint8Array::New(buffer, reinterpret_cast<char*>(&msg->{{=field.name}}) - data, sizeof(msg->{{=field.name}}));
    auto typesupport_msg = Nan::To<v8::Object>(Nan::Get(typesupport, Nan::New("{{=field.type.pkgName}}/{{=field.type.type}}").ToLocalChecked()).ToLocalChecked()).ToLocalChecked();
    auto typesupport_func = Nan::To<v8::Function>(Nan::Get(typesupport_msg, Nan::New("_toJsObject").ToLocalChecked()).ToLocalChecked()).ToLocalChecked();
    v8::Local<v8::Value> argv[] = {
      std::move(child_buffer)
    };
    auto {{=field.name}}_js_obj = Nan::Call(typesupport_func, Nan::New<v8::Object>(), 1, argv).ToLocalChecked();
    Nan::Set(js_obj, Nan::New("{{=field.name}}").ToLocalChecked(), {{=field.name}}_js_obj);
{{?}}
{{??}}
{{? field.type.isFixedSizeArray}}
    size_t field_offset = reinterpret_cast<char*>(msg->{{=field.name}}) - data;
{{? field.type.isPrimitiveType}}
    auto js_array = ToJsArrayChecked<std::decay_t<decltype(*msg->{{=field.name}})>>(buffer, field_offset, {{=field.type.arraySize}});
    Nan::Set(js_obj, Nan::New("{{=field.name}}").ToLocalChecked(), std::move(js_array));
{{??}}
    auto typesupport_msg = Nan::To<v8::Object>(Nan::Get(typesupport, Nan::New("{{=field.type.pkgName}}/{{=field.type.type}}").ToLocalChecked()).ToLocalChecked()).ToLocalChecked();
    Nan::Set(js_obj, Nan::New("{{=field.name}}").ToLocalChecked(), ToJsObjectArrayChecked<std::decay_t<decltype(*msg->{{=field.name}})>>(buffer, field_offset, {{=field.type.arraySize}}, typesupport_msg));
{{?}}
{{??}}
    auto sequence_buffer = Nan::NewBuffer(reinterpret_cast<char*>(msg->{{=field.name}}.data), msg->{{=field.name}}.size * sizeof(decltype(*msg->{{=field.name}}.data)), [](char*, void*) {}, nullptr).ToLocalChecked().As<v8::Uint8Array>();
    Nan::Set(sequence_buffer, Nan::New("_rclnodejs_owner").ToLocalChecked(), info[1]).ToChecked();
{{? field.type.isPrimitiveType}}
    Nan::Set(js_obj, Nan::New("{{=field.name}}").ToLocalChecked(), ToJsArrayChecked<std::decay_t<decltype(*msg->{{=field.name}}.data)>>(sequence_buffer->Buffer(), 0, msg->{{=field.name}}.size));
{{??}}
    auto typesupport_msg = Nan::To<v8::Object>(Nan::Get(typesupport, Nan::New("{{=field.type.pkgName}}/{{=field.type.type}}").ToLocalChecked()).ToLocalChecked()).ToLocalChecked();
    Nan::Set(js_obj, Nan::New("{{=field.name}}").ToLocalChecked(), ToJsObjectArrayChecked<std::decay_t<decltype(*msg->{{=field.name}}.data)>>(sequence_buffer->Buffer(), 0, msg->{{=field.name}}.size, typesupport_msg));
{{?}}
{{?}}
{{?}}
  }
{{?}}
{{~}}
  info.GetReturnValue().Set(js_obj);
}

NAN_METHOD(rclnodejs__{{=message.structType}}::InitSequence) {
  auto size = Nan::To<uint32_t>(info[0]).ToChecked();
  auto* msg = reinterpret_cast<{{=message.structType}}__Sequence*>(info[1].As<v8::External>()->Value());
  {{=message.structType}}__Sequence__init(msg, size);
}

{{~}}

NAN_MODULE_WORKER_ENABLED({{=it.pkgName}}, [](auto target) {
{{~ it.messages : message}}
  rclnodejs__{{=message.structType}}::Init(target);
{{~}}
});

} // namespace rclnodejs

#pragma GCC diagnostic pop
