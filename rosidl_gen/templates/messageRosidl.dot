// This file is automatically generated by Intel rclnodejs
//
// *** DO NOT EDIT directly
//

'use strict';

{{
let objectWrapper = it.spec.msgName + 'Wrapper';
let arrayWrapper = it.spec.msgName + 'ArrayWrapper';

let refObjectType = it.spec.msgName + 'RefStruct';
let refObjectArrayType = it.spec.msgName + 'RefStructArray';
let refArrayType = it.spec.msgName + 'RefArray';
const compactMsgDefJSON = JSON.stringify(JSON.parse(it.json));

if (it.spec.fields.length === 0) {
  it.spec.isEmpty = true;
  /* Following rosidl_generator_c style, put a bool member named '_dummy' */
  it.spec.fields.push({
    "type": {
      "isArray": false,
      "pkgName": null,
      "type": "bool",
      "isDynamicArray": false,
      "stringUpperBound": null,
      "isUpperBound": false,
      "isPrimitiveType": true,
      "isFixedSizeArray": false,
      "arraySize": null
    },
    "name": "_dummy"
  });
} /* if */

function getPrimitiveNameByType(type) {
  if (type.type === 'bool') {
    return 'Bool';
  } else if (type.type === 'int8') {
    return 'Int8';
  } else if (type.type === 'uint8') {
    return 'UInt8';
  } else if (type.type === 'int16') {
    return 'Int16';
  } else if (type.type === 'uint16') {
    return 'UInt16';
  } else if (type.type === 'int32') {
    return 'Int32';
  } else if (type.type === 'uint32') {
    return 'UInt32';
  } else if (type.type === 'int64') {
    return 'Int64';
  } else if (type.type === 'uint64') {
    return 'UInt64';
  } else if (type.type === 'float64') {
    return 'Float64';
  } else if (type.type === 'float32') {
    return 'Float32';
  } else if (type.type === 'char') {
    return 'Char';
  } else if (type.type === 'byte') {
    return 'Byte';
  } else if (type.type === 'string' || type.type === 'wstring') {
    return 'String';
  } else {
    return '';
  }
}

function getTypedArrayName(type) {
  const t = type.type.toLowerCase();
  let typedArrayName;

  switch (t) {
    case 'byte':
    case 'octet':
    case 'uint8':
      typedArrayName = 'Uint8Array';
      break;
    case 'char':
    case 'int8':
      typedArrayName = 'Int8Array';
      break;
    case 'int16':
    case 'short':
      typedArrayName = 'Int16Array';
      break;
    case 'uint16':
    case 'unsigned short':
      typedArrayName = 'Uint16Array';
      break;
    case 'int32':
    case 'long':
      typedArrayName = 'Int32Array';
      break;
    case 'uint32':
    case 'unsigned long':
      typedArrayName = 'Uint32Array';
      break;
    case 'float':
    case 'float32':
      typedArrayName = 'Float32Array';
      break;
    case 'double':
    case 'float64':
      typedArrayName = 'Float64Array';
      break;
    default:
      typedArrayName = '';
  }

  return typedArrayName;
}

function getTypedArrayElementName(type) {
  const t = type.type.toLowerCase();
  if (t === 'int8') {
    return 'int8';
  } else if (t === 'uint8') {
    return 'uint8';
  } else if (t === 'int16') {
    return 'int16';
  } else if (t === 'uint16') {
    return 'uint16';
  } else if (t === 'int32') {
    return 'int32';
  } else if (t === 'uint32') {
    return 'uint32';
  } else if (t === 'float64') {
    return 'double';
  } else if (t === 'float32') {
    return 'float';
  } else if (t === 'char') {
    return 'int8';
  } else if (t === 'byte') {
    return 'uint8';
  } else {
    return '';
  }
}

const primitiveBaseType = ['Bool', 'Int8', 'UInt8', 'Int16', 'UInt16', 'Int32', 'UInt32',
                           'Int64', 'UInt64', 'Float64', 'Float32', 'Char', 'Byte', 'String'];
const typedArrayType = ['int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32',
                        'float64', 'float32', 'char', 'byte'];

let existedModules = [];

function isExisted(requiredModule) {
  return existedModules.indexOf(requiredModule) !== -1;
}

function isPrimitivePackage(baseType) {
  return primitiveBaseType.indexOf(baseType.type) !== -1;
}

function isTypedArrayType(type) {
  return typedArrayType.indexOf(type.type.toLowerCase()) !== -1;
}

const usePlainTypedArray = isTypedArrayType(it.spec.baseType);
const currentTypedArray = getTypedArrayName(it.spec.baseType);
const currentTypedArrayElementType = getTypedArrayElementName(it.spec.baseType);

function shouldRequire(baseType, fieldType) {
  let requiredModule = '{{=getPackageNameByType(fieldType)}}/{{=getModulePathByType(fieldType)}}';
  let shouldRequire = !isPrimitivePackage(baseType) && !fieldType.isPrimitiveType;

  if (shouldRequire && !isExisted(requiredModule)) {
    existedModules.push(requiredModule);
    return true;
  } else {
    return false;
  }
}

function getWrapperNameByType(type) {
  if (type.isPrimitiveType) {
    return getPrimitiveNameByType(type) + 'Wrapper';
  } else {
    return type.type + 'Wrapper';
  }
}

function getModulePathByType(type, messageInfo) {
  if (type.isPrimitiveType) {
    return 'std_msgs__msg__' + getPrimitiveNameByType(type) + '.js';
  }

  if (
    messageInfo &&
    messageInfo.subFolder === 'action' &&
    messageInfo.pkgName === type.pkgName &&
    (type.type.endsWith('_Goal') || type.type.endsWith('_Result') || type.type.endsWith('_Feedback'))
  ) {
    return type.pkgName + '__action__' + type.type + '.js';
  }

  return type.pkgName + '__msg__' + type.type + '.js';
}

function getPackageNameByType(type) {
  if (type.isPrimitiveType) {
    return 'std_msgs';
  } else {
    return type.pkgName;
  }
}

function extractMemberNames(fields) {
  let memberNames = [];
  fields.forEach(field => {
    memberNames.push(field.name);
  });
  return JSON.stringify(memberNames);
}
}}

const typesupport = require('bindings')('{{=it.messageInfo.pkgName}}__rosidl_node').{{=it.messageInfo.interfaceName}};

const typesupportDeps = {};
{{~ it.spec.fields :field}}
  {{? shouldRequire(it.spec.baseType, field.type)}}
const {{=getWrapperNameByType(field.type)}} = require('../../generated/{{=getPackageNameByType(field.type)}}/{{=getModulePathByType(field.type, it.messageInfo)}}');
    {{? it.options.idlProvider === 'rosidl' && field.type.pkgName}}
typesupportDeps['{{=field.type.pkgName}}/{{=field.type.type}}'] = {{=getWrapperNameByType(field.type)}};
    {{?}}
  {{?}}
{{~}}

// Define the wrapper class.
class {{=objectWrapper}} {
  constructor(other) {
    this._rawRos = undefined;
    if (other === undefined) {
      this._rawRos = {{=objectWrapper}}._createRosMessage();
      this._proxyObj = {{=objectWrapper}}._toJsObject(this._rawRos);
    } else if (other instanceof {{=objectWrapper}}) {
      this._proxyObj = other._proxyObj;
    } else {
      this._proxyObj = other;
    }
  }

  static _createRosMessage() {
    return typesupport.createRosMessage();
  }

  static _toJsObject(rawRos) {
    return typesupport.toJsObject(typesupportDeps, rawRos);
  }

  static _toRosMessage(obj) {
    const rosMessage = {{=objectWrapper}}._createRosMessage();
    {{=objectWrapper}}._writeRosMessage(obj, rosMessage);
    return rosMessage;
  }

  static _writeRosMessage(obj, rawRos) {
    typesupport.writeRosMessage(typesupportDeps, obj, rawRos);
  }

  static _initSequence(size, rawRos) {
    typesupport.initSequence(size, rawRos);
  }

  toRawROS() {
    this.freeze();
    return this._rawRos;
  }

  freeze(own = false, checkConsistency = false) {
    this._rawRos = {{=objectWrapper}}._toRosMessage(this._proxyObj);
  }

  serialize() {
    return this.toRawROS();
  }

  deserialize(rawRos) {
    this._proxyObj = {{=objectWrapper}}._toJsObject(rawRos);
  }

  toPlainObject(enableTypedArray) {
    return this._proxyObj;
  }

  static freeStruct(refObject) {
    // managed by v8 gc
  }

  static destoryRawROS(msg) {
    // managed by v8 gc
  }

  static type() {
    return {pkgName: '{{=it.messageInfo.pkgName}}', subFolder: '{{=it.messageInfo.subFolder}}', interfaceName: '{{=it.messageInfo.interfaceName}}'};
  }

  static isPrimitive() {
    return {{=isPrimitivePackage(it.spec.baseType)}};
  }

  static get isROSArray() {
    return false;
  }

  get refObject() {
    return this._rawRos;
  }

  {{~ it.spec.fields :field}}
  get {{=field.name}}() {
    return this._proxyObj['{{=field.name}}'];
  }

  set {{=field.name}}(value) {
    this._proxyObj['{{=field.name}}'] = value;
  }
  {{~}}

  copy(other) {
    this._proxyObj = other._proxyObj;
  }

  static get classType() {
    return {{=objectWrapper}};
  }

  static get ROSMessageDef() {
    return {{=compactMsgDefJSON}};
  }

  hasMember(name) {
    let memberNames = {{=extractMemberNames(it.spec.fields)}};
    return memberNames.indexOf(name) !== -1;
  }
}

module.exports = {{=objectWrapper}};

/*
 * The following is the original spec object coming from parser:
{{=it.json}}
*/
