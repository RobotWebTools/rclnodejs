// This file is automatically generated by Intel rclnodejs
//
// *** DO NOT EDIT directly
//

'use strict';

const StructType = require('ref-struct');
const ref = require('ref');
const ArrayType = require('ref-array');
const primitiveTypes = require('../rosidl_gen/generator_primitive.js');

{{
var className = it.className;
var arrayClassName = className + '__Array';
var generatorName = 'rosidl_generator_nodejs__' + className;
var generatorArrayTypeName = generatorName + '__ArrayType';
var generatorArrayName = generatorName + '__Array';

if (it.spec.fields.length === 0) {
  /* Following rosidl_generator_c style, put a bool member named '_dummy' */
  it.spec.fields.push({
    "type": {
      "isArray": false,
      "pkgName": null,
      "type": "bool",
      "isDynamicArray": false,
      "stringUpperBound": null,
      "isUpperBound": false,
      "isPrimitiveType": true,
      "isFixedSizeArray": false,
      "arraySize": null
    },
    "name": "_dummy"
  });
} /* if */

var isStruct = function(type) {
  return !type.isPrimitiveType && !type.isArray;
};

var isStructArray = function(type) {
  return !type.isPrimitiveType && type.isArray;
};

var isPrimitiveArray = function(type) {
  return type.isPrimitiveType && type.isArray;
};

var shouldRequireType = function(type) {
  return !type.isPrimitiveType;
};

var isPrimitive = function(type) {
  return type.isPrimitiveType && !type.isArray;
};

var isString = function(type) {
  return type.type === 'string' && !type.isArray;
};

var calcStructTypeName = function(type) {
  return type.pkgName + '__msg__' + type.type;
};

var calcFileNameFromType = function(type) {
  return calcStructTypeName(type) + '.js';
};

var calcGeneratorTypeNameFromType = function(type) {
  return "rosidl_generator_nodejs__" + type.pkgName + '__msg__' + type.type;
};

}}
// TODO: remove duplicated (if any)
{{~ it.spec.fields :field}}
{{? shouldRequireType(field.type)}}
var {{=calcStructTypeName(field.type)}} = require('../generated/{{=calcFileNameFromType(field.type)}}');
{{?}}
{{~}}

//
// Define the struct type
//
const {{=generatorName}} = StructType({
{{~ it.spec.fields :field}}

{{? isPrimitive(field.type)}}
  {{=field.name}}: primitiveTypes.{{=field.type.type}},
{{?? isPrimitiveArray(field.type)}}
  {{=field.name}}: primitiveTypes.{{=field.type.type}}, // TODO(Kenny): it's actually an array, need to generate a primitive type array
{{?? isStructArray(field.type)}}
  {{=field.name}}: {{=calcStructTypeName(field.type)}}.RawStructType, // TODO(Kenny): it's actually an array, need to generate a struct type array
{{?? true}}
  {{=field.name}}: {{=calcStructTypeName(field.type)}}.RawStructType,
{{?}}

{{~}}
});

//
// Define the ref-array type
//

const {{=generatorArrayTypeName}} = ArrayType({{=generatorName}});

//
// Define the array type structure
//
const {{=generatorArrayName}} = StructType({
  data: ref.refType({{=generatorName}}),
  size: ref.types.size_t,
  capacity: ref.types.size_t,
});

//
// Define the wrapper class
//
class {{=className}} {
  constructor(other) {
    let otherObj = undefined;
    if (typeof other === 'object' && other.__ref_message) {
      otherObj = other.__ref_message.toObject();
    }
    this.__ref_message = new {{=generatorName}}(otherObj);
    this.__ref_object = {};
  }

{{~ it.spec.fields :field}}
  get {{=field.name}}() {
  {{? isString(field.type)}}
    return this.__ref_message.{{=field.name}}.data;
  {{?? isStruct(field.type)}}
    if (!this.__ref_object['{{=field.name}}']) {
      this.__ref_object['{{=field.name}}'] = new {{=calcStructTypeName(field.type)}}();
      this.__ref_object['{{=field.name}}'].__ref_message = this.__ref_message.{{=field.name}};
    }
    return this.__ref_object.{{=field.name}};
  {{?? true}}
    return this.__ref_message.{{=field.name}};
  {{?}}
  }

  set {{=field.name}}(value) {
  {{? isString(field.type)}}
    primitiveTypes.string__assign(this.__ref_message.{{=field.name}}, value);
  {{?? isStruct(field.type)}}
    if (!this.__ref_object['{{=field.name}}']) {
      this.__ref_object['{{=field.name}}'] = new {{=calcStructTypeName(field.type)}}();
      this.__ref_object['{{=field.name}}'].__ref_message = this.__ref_message.{{=field.name}};
    }
    if (! value instanceof {{=calcStructTypeName(field.type)}}) {
      throw new TypeError('Invalid argument: should provide "{{=calcStructTypeName(field.type)}}" to ".{{=field.name}}" setter');
    }
    this.__ref_object.{{=field.name}}.copy(value);
  {{?? true}}
    this.__ref_message.{{=field.name}} = value;
  {{?}}
  }
{{~}}

  copy(other) {
    this.__ref_message = new {{=generatorName}}(other.__ref_message.toObject());
  }

}

//
// Define the wrapper array class
//
class {{=arrayClassName}} {
  constructor(sz = 1) {
    this.__resize(sz);
  }

  get data() {
    return this.__ref_array;
  }

  get size() {
    return this.__ref_array.length;
  }

  set size(v) {
    if (typeof v != 'number') {
      throw new TypeError('Invalid argument: should provide a number to {{=arrayClassName}}.size setter');
      return;
    }

    return this.__resize(v);
  }

  get capacity() {
    return this.__ref_array.length;
  }

  set capacity(v) {
    if (typeof v != 'number') {
      throw new TypeError('Invalid argument: should provide a number to {{=arrayClassName}}.capacity setter');
      return;
    }

    return this.__resize(v);
  }

  __resize(sz) {
    if (sz <= 0) {
      throw new RangeError('Invalid argument: should provide a positive number to {{=arrayClassName}}.size/capacity setter');
      return;
    }

    // TODO: data detain policy
    // TODO: use binding functions instead of ref-array type
    this.__ref_message = new {{=generatorArrayName}}();
    this.__ref_message.size = sz;
    this.__ref_message.capacity = sz;
    this.__ref_message.arrayTypeData = new {{=generatorArrayTypeName}}(sz);
    this.__ref_message.data = this.__ref_message.arrayTypeData.ref();

    // Now update __ref_array objects
    this.__ref_array = new Array(sz);
    for (let i = 0; i < this.__ref_array.length; ++i) {
      this.__ref_array[i] = new {{=className}}();
      this.__ref_array[i].__ref_message = this.__ref_message.arrayTypeData[i]; // TODO: fill it using data
    }
  }

  copy(other) {
    this.__resize(other.size);

    // Array deep copy
    for (let i = 0; i < this.__ref_array.length; ++ i) {
      this.__ref_array[i].copy(other.__ref_array[i]);
    }
  }
}

{{? it.spec.constants != undefined && it.spec.constants.length}}
//
// Define constants ({{=it.spec.constants.length}} in total)
//
{{~ it.spec.constants :c}}
Object.defineProperty({{=className}}, "{{=c.name}}", {value: {{=c.value}}, writable: false, enumerable: true, configurable: true});
{{~}}
{{?}}
// Raw type and wrapper type
{{=className}}.RawStructType = {{=generatorName}};
{{=generatorName}}.WrapperType = {{=className}};
//
// Array Type for type: {{=className}}
//
{{=className}}.RawArrayType = {{=generatorArrayName}};
{{=className}}.ArrayType = {{=arrayClassName}};
{{=className}}.ArrayType.RawArrayType = {{=generatorArrayName}};
//
// Expose internal buffer
//
{{=className}}.getRefBuffer = function(msg) {
  return msg.__ref_message.ref();
};

module.exports = {{=className}};

/*
 * The following is the original spec object coming from parser:

{{=it.json}}

*/
