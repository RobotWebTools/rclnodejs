// This file is automatically generated by Intel rclnodejs
//
// *** DO NOT EDIT directly
//

'use strict';

const StructType = require('ref-struct');
const ref = require('ref');
const ArrayType = require('ref-array');
const primitiveTypes = require('../../rosidl_gen/generator_primitive.js');
const deallocator = require('../../rosidl_gen/deallocator.js');

{{
let objectWrapper = it.spec.msgName + 'Wrapper';
let arrayWrapper = it.spec.msgName + 'ArrayWrapper';

let refObjectType = it.spec.msgName + 'RefStruct';
let refObjectArrayType = it.spec.msgName + 'RefStructArray';
let refArrayType = it.spec.msgName + 'RefArray';

if (it.spec.fields.length === 0) {
  /* Following rosidl_generator_c style, put a bool member named '_dummy' */
  it.spec.fields.push({
    "type": {
      "isArray": false,
      "pkgName": null,
      "type": "bool",
      "isDynamicArray": false,
      "stringUpperBound": null,
      "isUpperBound": false,
      "isPrimitiveType": true,
      "isFixedSizeArray": false,
      "arraySize": null
    },
    "name": "_dummy"
  });
} /* if */

function getPrimitiveNameByType(type) {
  if (type.type === 'bool') {
    return 'Bool';
  } else if (type.type === 'int8') {
    return 'Int8';
  } else if (type.type === 'uint8') {
    return 'UInt8';
  } else if (type.type === 'int16') {
    return 'Int16';
  } else if (type.type === 'uint16') {
    return 'UInt16';
  } else if (type.type === 'int32') {
    return 'Int32';
  } else if (type.type === 'uint32') {
    return 'UInt32';
  } else if (type.type === 'int64') {
    return 'Int64';
  } else if (type.type === 'uint64') {
    return 'UInt64';
  } else if (type.type === 'float64') {
    return 'Float64';
  } else if (type.type === 'float32') {
    return 'Float32';
  } else if (type.type === 'char') {
    return 'Char';
  } else if (type.type === 'byte') {
    return 'Byte';
  } else if (type.type === 'string') {
    return 'String';
  } else {
    return '';
  }
}

let primitiveBaseType = ['Bool', 'Int8', 'UInt8', 'Int16', 'UInt16', 'Int32', 'UInt32',
                         'Int64', 'UInt64', 'Float64', 'Float32', 'Char', 'Byte', 'String'];

let existedModules = [];

function isExisted(requiredModule) {
  return existedModules.indexOf(requiredModule) !== -1;
}

function isPrimitivePackage(baseType) {
  return primitiveBaseType.indexOf(baseType.type) !== -1;
}

function shouldRequire(baseType, fieldType) {
  let requiredModule = '{{=getPackageNameByType(fieldType)}}/{{=getJSFileNameByType(fieldType)}}';
  let shouldRequire = !isPrimitivePackage(baseType) && (fieldType.isArray || !fieldType.isPrimitiveType || fieldType.type === 'string');

  if (shouldRequire && !isExisted(requiredModule)) {
    existedModules.push(requiredModule);
    return true;
  } else {
    return false;
  }
}

function getWrapperNameByType(type) {
  if (type.isPrimitiveType) {
    return getPrimitiveNameByType(type) + 'Wrapper';
  } else {
    return type.type + 'Wrapper';
  }
}

function getJSFileNameByType(type) {
    if (type.isPrimitiveType) {
    return 'std_msgs__msg__' + getPrimitiveNameByType(type) + '.js';
  } else {
    return type.pkgName + '__msg__' + type.type + '.js';
  }
}

function getPackageNameByType(type) {
  if (type.isPrimitiveType) {
    return 'std_msgs';
  } else {
    return type.pkgName;
  }
}
}}

{{~ it.spec.fields :field}}
{{? shouldRequire(it.spec.baseType, field.type)}}
let {{=getWrapperNameByType(field.type)}} = require('../../generated/{{=getPackageNameByType(field.type)}}/{{=getJSFileNameByType(field.type)}}');
{{?}}
{{~}}

{{? it.spec.msgName === 'String'}}
const {{=refObjectType}} = primitiveTypes.string;
{{??}}
const {{=refObjectType}} = StructType({
  {{~ it.spec.fields :field}}
  {{? field.type.isPrimitiveType && !field.type.isArray}}
  {{=field.name}}: primitiveTypes.{{=field.type.type}},
  {{?? field.type.isArray}}
  {{=field.name}}: {{=getWrapperNameByType(field.type)}}.refObjectArrayType,
  {{?? true}}
  {{=field.name}}: {{=getWrapperNameByType(field.type)}}.refObjectType,
  {{?}}
  {{~}}
});
{{?}}

const {{=refArrayType}} = ArrayType({{=refObjectType}});
const {{=refObjectArrayType}} = StructType({
  data: ArrayType({{=refObjectType}}),
  size: ref.types.size_t,
  capacity: ref.types.size_t,
});

// Define the wrapper class.
class {{=objectWrapper}} {
  constructor(other) {
    this._wrapperFields = {};
    if (typeof other === 'object' && other._refObject) {
      this._refObject = new {{=refObjectType}}(other._refObject.toObject());
      {{~ it.spec.fields :field}}
      {{? field.type.isArray || !field.type.isPrimitiveType || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
      this._wrapperFields.{{=field.name}} =  new {{=getWrapperNameByType(field.type)}}(other._wrapperFields.{{=field.name}});
      {{?}}
      {{~}}
    } else {
      this._refObject = new {{=refObjectType}}();
      {{~ it.spec.fields :field}}
      {{? field.type.isArray}}
      this._wrapperFields.{{=field.name}} = {{=getWrapperNameByType(field.type)}}.createArray();
      {{?? !field.type.isPrimitiveType || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
      this._wrapperFields.{{=field.name}} = new {{=getWrapperNameByType(field.type)}}();
      {{?? it.spec.msgName === 'String'}}
      primitiveTypes.initString(this._refObject);
      {{?}}
      {{~}}
    }
    this.freeze();
  }

  static createFromRefObject(refObject) {
    let self = new {{=objectWrapper}}();
    self.copyRefObject(refObject);
    return self;
  }

  static createArray() {
    return new {{=arrayWrapper}};
  }

  static get ArrayType() {
    return {{=arrayWrapper}};
  }

  static get refObjectArrayType() {
    return {{=refObjectArrayType}}
  }

  static get refObjectType() {
    return {{=refObjectType}};
  }

  toRawROS() {
    this.freeze(true);
    return this._refObject.ref();
  }

  freeze(own = false) {
    {{~ it.spec.fields :field}}
    {{? !field.type.isPrimitiveType || field.type.isArray}}
    this._wrapperFields.{{=field.name}}.freeze(own);
    this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    {{?? field.type.type === 'string' && it.spec.msgName !== 'String'}}
    if (own) {
      primitiveTypes.initString(this._wrapperFields.{{=field.name}}.refObject.ref(), own);
    }
    this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    {{?? it.spec.msgName === 'String'}}
    if (own) {
      primitiveTypes.initString(this._refObject.ref(), own);
    }
    {{?}}
    {{~}}
  }

  serialize() {
    this.freeze();
    return this._refObject.ref();
  }

  deserialize(refObject) {
    {{~ it.spec.fields :field}}
    {{? !field.type.isPrimitiveType || field.type.isArray}}
    this._wrapperFields.{{=field.name}}.copyRefObject(refObject.{{=field.name}});
    {{?? field.type.type === 'string' && it.spec.msgName !== 'String'}}
    this._wrapperFields.{{=field.name}}.data = refObject.{{=field.name}}.data;
    {{?? field.type.isPrimitiveType}}
    this._refObject.{{=field.name}} = refObject.{{=field.name}};
    {{?}}
    {{~}}
  }

  static freeStruct(refObject) {
    {{~ it.spec.fields :field}}
    {{? field.type.isArray}}
    if (refObject.{{=field.name}}.size != 0) {
      {{=getWrapperNameByType(field.type)}}.ArrayType.freeArray(refObject.{{=field.name}});
      deallocator.freeStructMember(refObject.{{=field.name}}, {{=getWrapperNameByType(field.type)}}.refObjectArrayType, 'data');
    }
    {{?? !field.type.isPrimitiveType || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
    {{=getWrapperNameByType(field.type)}}.freeStruct(refObject.{{=field.name}});
    {{?? it.spec.msgName === 'String'}}
    deallocator.freeStructMember(refObject, {{=getWrapperNameByType(field.type)}}.refObjectType, '{{=field.name}}');
    {{?}}
    {{~}}
  }

  static destoryRawROS(msg) {
    {{=objectWrapper}}.freeStruct(msg.refObject);
  }

  static type() {
    return {pkgName: '{{=it.messageInfo.pkgName}}', subFolder: '{{=it.messageInfo.subFolder}}', interfaceName: '{{=it.messageInfo.interfaceName}}'};
  }

  isPrimitive() {
    return {{=isPrimitivePackage(it.spec.baseType)}};
  }

  get refObject() {
    return this._refObject;
  }

  {{~ it.spec.fields :field}}
  get {{=field.name}}() {
    {{? field.type.isArray && field.type.isPrimitiveType}}
    let values = [];
    this._wrapperFields['{{=field.name}}'].data.forEach((wrapper, index) => {
      values.push(wrapper.data);
    });
    return values;
    {{?? field.type.isArray && !field.type.isPrimitiveType}}
    return this._wrapperFields.{{=field.name}};
    {{?? !field.type.isPrimitiveType && !field.type.isArray}}
    return this._wrapperFields.{{=field.name}};
    {{?? !field.type.isArray && field.type.type === 'string' && it.spec.msgName !== 'String'}}
    return this._wrapperFields.{{=field.name}}.data;
    {{?? true}}
    return this._refObject.{{=field.name}};
    {{?}}
  }

  set {{=field.name}}(value) {
    {{? field.type.isArray && field.type.isPrimitiveType}}
    this._wrapperFields['{{=field.name}}'].fill(value);
    {{?? field.type.isArray && !field.type.isPrimitiveType}}
    this._wrapperFields.{{=field.name}}.copy(value);
    {{?? !field.type.isPrimitiveType && !field.type.isArray}}
    this._wrapperFields.{{=field.name}}.copy(value);
    {{?? !field.type.isArray && field.type.type === 'string' && it.spec.msgName !== 'String'}}
    this._wrapperFields.{{=field.name}}.data = value;
    {{?? true}}
    {{? it.spec.msgName === 'String'}}
    this._refObject.size = value.length;
    this._refObject.capacity = value.length + 1;
    {{?}}
    this._refObject.{{=field.name}} = value;
    {{?}}
  }
  {{~}}

  copyRefObject(refObject) {
    this._refObject = new {{=refObjectType}}(refObject.toObject());

    {{~ it.spec.fields :field}}
    {{? !field.type.isPrimitiveType || field.type.isArray || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
    this._wrapperFields.{{=field.name}}.copyRefObject(this._refObject.{{=field.name}});
    {{?}}
    {{~}}
  }

  copy(other) {
    this._refObject = new {{=refObjectType}}(other._refObject.toObject());

    {{~ it.spec.fields :field}}
    {{? !field.type.isPrimitiveType || field.type.isArray || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
    this._wrapperFields.{{=field.name}}.copy(other._wrapperFields.{{=field.name}});
    {{?}}
    {{~}}
  }
}

// Define the wrapper of array class.
class {{=arrayWrapper}} {
  constructor(size = 0) {
    this._resize(size);
  }

  toRawROS() {
    return this._refObject.ref();
  }

  fill(values) {
    let length = values.length;
    this._resize(length);
    {{? isPrimitivePackage(it.spec.baseType)}}
    values.forEach((value, index) => {
      let wrapper = new {{=objectWrapper}}();
      wrapper.data = value;
      this._wrappers[index] = wrapper;
    });
    {{?? !isPrimitivePackage(it.spec.baseType)}}
    values.forEach((value, index) => {
      this._wrappers[index].copy(value);
    });
    {{?}}
  }

  freeze(own) {
    this._wrappers.forEach((wrapper, index) => {
      wrapper.freeze(own);
      this._refArray[index] = wrapper.refObject;
    });
    this._refObject.size = this._wrappers.length;
    this._refObject.capacity = this._wrappers.length;
    this._refObject.data = this._refArray.buffer;
  }

  get refObject() {
    return this._refObject;
  }

  get data() {
    return this._wrappers;
  }

  get size() {
    return this._wrappers.length;
  }

  set size(value) {
    if (typeof value != 'number') {
      throw new TypeError('Invalid argument: should provide a number to {{=arrayWrapper}}.size setter');
      return;
    }
    return this._resize(value);
  }

  get capacity() {
    return this._wrappers.length;
  }

  set capacity(value) {
    if (typeof value != 'number') {
      throw new TypeError('Invalid argument: should provide a number to {{=arrayWrapper}}.capacity setter');
    }
    return this._resize(value);
  }

  get refObject() {
    return this._refObject;
  }

  _resize(size) {
    if (size < 0) {
      throw new RangeError('Invalid argument: should provide a positive number');
      return;
    }
    this._refArray = new {{=refArrayType}}(size);
    this._refObject = new {{=refObjectArrayType}}();
    this._refObject.size = size;
    this._refObject.capacity = size;

    this._wrappers = new Array();
    for (let i = 0; i < size; i++) {
      this._wrappers.push(new {{=objectWrapper}}());
    }
  }

  copyRefObject(refObject) {
    this._refObject = refObject;
    let refObjectArray = this._refObject.data;
    refObjectArray.length = this._refObject.size;
    this._resize(this._refObject.size);

    for (let index = 0; index < this._refObject.size; index++) {
      this._wrappers[index].copyRefObject(refObjectArray[index]);
    }
  }

  copy(other) {
    if (! other instanceof {{=arrayWrapper}}) {
      throw new TypeError('Invalid argument: should provide "{{=arrayWrapper}}".');
    }

    this._resize(other.size);
    // Array deep copy
    other._wrappers.forEach((wrapper, index) => {
      this._wrappers[index].copy(wrapper);
    });
  }

  static freeArray(refObject) {
    let refObjectArray = refObject.data;
    refObjectArray.length = refObject.size;
    for (let index = 0; index < refObject.size; index++) {
      {{=objectWrapper}}.freeStruct(refObjectArray[index]);
    }
  }
}

{{? it.spec.constants != undefined && it.spec.constants.length}}
// Define constants ({{=it.spec.constants.length}} in total)
{{~ it.spec.constants :c}}
Object.defineProperty({{=objectWrapper}}, "{{=c.name}}", {value: {{=c.value}}, writable: false, enumerable: true, configurable: true});
{{~}}
{{?}}

module.exports = {{=objectWrapper}};

/*
 * The following is the original spec object coming from parser:
{{=it.json}}
*/
