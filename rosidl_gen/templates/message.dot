// This file is automatically generated by Intel rclnodejs
//
// *** DO NOT EDIT directly
//

'use strict';

{{
let objectWrapper = it.spec.msgName + 'Wrapper';
let arrayWrapper = it.spec.msgName + 'ArrayWrapper';

let refObjectType = it.spec.msgName + 'RefStruct';
let refObjectArrayType = it.spec.msgName + 'RefStructArray';
let refArrayType = it.spec.msgName + 'RefArray';
const compactMsgDefJSON = JSON.stringify(JSON.parse(it.json));

if (it.spec.fields.length === 0) {
  it.spec.isEmpty = true;
  /* Following rosidl_generator_c style, put a bool member named '_dummy' */
  it.spec.fields.push({
    "type": {
      "isArray": false,
      "pkgName": null,
      "type": "bool",
      "isDynamicArray": false,
      "stringUpperBound": null,
      "isUpperBound": false,
      "isPrimitiveType": true,
      "isFixedSizeArray": false,
      "arraySize": null
    },
    "name": "_dummy"
  });
} /* if */

function getPrimitiveNameByType(type) {
  if (type.type === 'bool') {
    return 'Bool';
  } else if (type.type === 'int8') {
    return 'Int8';
  } else if (type.type === 'uint8') {
    return 'UInt8';
  } else if (type.type === 'int16') {
    return 'Int16';
  } else if (type.type === 'uint16') {
    return 'UInt16';
  } else if (type.type === 'int32') {
    return 'Int32';
  } else if (type.type === 'uint32') {
    return 'UInt32';
  } else if (type.type === 'int64') {
    return 'Int64';
  } else if (type.type === 'uint64') {
    return 'UInt64';
  } else if (type.type === 'float64') {
    return 'Float64';
  } else if (type.type === 'float32') {
    return 'Float32';
  } else if (type.type === 'char') {
    return 'Char';
  } else if (type.type === 'byte') {
    return 'Byte';
  } else if (type.type === 'string' || type.type === 'wstring') {
    return 'String';
  } else {
    return '';
  }
}

function getTypedArrayName(type) {
  const t = type.type.toLowerCase();
  let typedArrayName;

  switch (t) {
    case 'byte':
    case 'octet':
    case 'uint8':
      typedArrayName = 'Uint8Array';
      break;
    case 'char':
    case 'int8':
      typedArrayName = 'Int8Array';
      break;
    case 'int16':
    case 'short':
      typedArrayName = 'Int16Array';
      break;
    case 'uint16':
    case 'unsigned short':
      typedArrayName = 'Uint16Array';
      break;
    case 'int32':
    case 'long':
      typedArrayName = 'Int32Array';
      break;
    case 'uint32':
    case 'unsigned long':
      typedArrayName = 'Uint32Array';
      break;
    case 'float':
    case 'float32':
      typedArrayName = 'Float32Array';
      break;
    case 'double':
    case 'float64':
      typedArrayName = 'Float64Array';
      break;
    default:
      typedArrayName = '';
  }

  return typedArrayName;
}

function getTypedArrayElementName(type) {
  const t = type.type.toLowerCase();
  if (t === 'int8') {
    return 'int8';
  } else if (t === 'uint8') {
    return 'uint8';
  } else if (t === 'int16') {
    return 'int16';
  } else if (t === 'uint16') {
    return 'uint16';
  } else if (t === 'int32') {
    return 'int32';
  } else if (t === 'uint32') {
    return 'uint32';
  } else if (t === 'float64') {
    return 'double';
  } else if (t === 'float32') {
    return 'float';
  } else if (t === 'char') {
    return 'int8';
  } else if (t === 'byte') {
    return 'uint8';
  } else {
    return '';
  }
}

const primitiveBaseType = ['Bool', 'Int8', 'UInt8', 'Int16', 'UInt16', 'Int32', 'UInt32',
                           'Int64', 'UInt64', 'Float64', 'Float32', 'Char', 'Byte', 'String'];
const typedArrayType = ['int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32',
                        'float64', 'float32', 'char', 'byte'];

let existedModules = [];

function isExisted(requiredModule) {
  return existedModules.indexOf(requiredModule) !== -1;
}

function isPrimitivePackage(baseType) {
  return primitiveBaseType.indexOf(baseType.type) !== -1;
}

function isTypedArrayType(type) {
  return typedArrayType.indexOf(type.type.toLowerCase()) !== -1;
}

const usePlainTypedArray = isTypedArrayType(it.spec.baseType);
const currentTypedArray = getTypedArrayName(it.spec.baseType);
const currentTypedArrayElementType = getTypedArrayElementName(it.spec.baseType);

function shouldRequire(baseType, fieldType) {
  let requiredModule = '{{=getPackageNameByType(fieldType)}}/{{=getModulePathByType(fieldType)}}';
  let shouldRequire = !isPrimitivePackage(baseType) && (fieldType.isArray || !fieldType.isPrimitiveType || fieldType.type === 'string');

  if (shouldRequire && !isExisted(requiredModule)) {
    existedModules.push(requiredModule);
    return true;
  } else {
    return false;
  }
}

function getWrapperNameByType(type) {
  if (type.isPrimitiveType) {
    return getPrimitiveNameByType(type) + 'Wrapper';
  } else {
    return type.type + 'Wrapper';
  }
}

function getModulePathByType(type, messageInfo) {
  if (type.isPrimitiveType) {
    return 'std_msgs__msg__' + getPrimitiveNameByType(type) + '.js';
  }

  if (
    messageInfo &&
    messageInfo.subFolder === 'action' &&
    messageInfo.pkgName === type.pkgName &&
    (type.type.endsWith('_Goal') || type.type.endsWith('_Result') || type.type.endsWith('_Feedback'))
  ) {
    return type.pkgName + '__action__' + type.type + '.js';
  }

  return type.pkgName + '__msg__' + type.type + '.js';
}

function getPackageNameByType(type) {
  if (type.isPrimitiveType) {
    return 'std_msgs';
  } else {
    return type.pkgName;
  }
}

function extractMemberNames(fields) {
  let memberNames = [];
  fields.forEach(field => {
    memberNames.push(field.name);
  });
  return JSON.stringify(memberNames);
}
}}

{{? usePlainTypedArray}}
const rclnodejs = require('bindings')('rclnodejs');
{{?}}
const ref = require('ref-napi');
const StructType = require('ref-struct-di')(ref);
const ArrayType = require('ref-array-di')(ref);
const primitiveTypes = require('../../rosidl_gen/primitive_types.js');
const deallocator = require('../../rosidl_gen/deallocator.js');
const translator = require('../../rosidl_gen/message_translator.js');

{{~ it.spec.fields :field}}
{{? shouldRequire(it.spec.baseType, field.type)}}
const {{=getWrapperNameByType(field.type)}} = require('../../generated/{{=getPackageNameByType(field.type)}}/{{=getModulePathByType(field.type, it.messageInfo)}}');
{{?}}
{{~}}

{{? it.spec.msgName === 'String'}}
const {{=refObjectType}} = primitiveTypes.string;
{{??}}
const {{=refObjectType}} = StructType({
{{~ it.spec.fields :field}}
  {{? field.type.isPrimitiveType && !field.type.isArray}}
  {{=field.name}}: primitiveTypes.{{=field.type.type}},
  {{?? field.type.isPrimitiveType && field.type.isArray && field.type.isFixedSizeArray}}
  {{=field.name}}: ArrayType(primitiveTypes.{{=field.type.type}}, {{=field.type.arraySize}}),
  {{?? !field.type.isPrimitiveType && field.type.isArray && field.type.isFixedSizeArray}}
  {{=field.name}}: ArrayType({{=getWrapperNameByType(field.type)}}.refObjectType, {{=field.type.arraySize}}),
  {{?? field.type.isArray}}
  {{=field.name}}: {{=getWrapperNameByType(field.type)}}.refObjectArrayType,
  {{?? true}}
  {{=field.name}}: {{=getWrapperNameByType(field.type)}}.refObjectType,
  {{?}}
{{~}}
});
{{?}}

const {{=refArrayType}} = ArrayType({{=refObjectType}});
const {{=refObjectArrayType}} = StructType({
{{? usePlainTypedArray}}
  data: ref.refType(ref.types.{{=currentTypedArrayElementType}}),
{{?? true}}
  data: {{=refArrayType}},
{{?}}
  size: ref.types.size_t,
  capacity: ref.types.size_t
});

// Define the wrapper class.
class {{=objectWrapper}} {
  constructor(other) {
    this._wrapperFields = {};
    {{~ it.spec.fields :field}}
    {{? field.type.isArray && field.type.isPrimitiveType && !isTypedArrayType(field.type)}}
    this._{{=field.name}}Array = [];
    {{?}}
    {{~}}

    if (typeof other === 'object' && other._refObject) {
      this._refObject = new {{=refObjectType}}(other._refObject.toObject());
      {{~ it.spec.fields :field}}
      {{? field.type.isPrimitiveType && !field.type.isArray}}
      this._{{=field.name}}Intialized = true;
      {{?}}

      {{? field.type.isArray}}
      this._wrapperFields.{{=field.name}} = {{=getWrapperNameByType(field.type)}}.createArray();
      this._wrapperFields.{{=field.name}}.copy(other._wrapperFields.{{=field.name}});
      {{? field.type.isPrimitiveType && !isTypedArrayType(field.type)}}
      this.{{=field.name}} = other.{{=field.name}};
      {{?}}
      {{?? !field.type.isPrimitiveType || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
      this._wrapperFields.{{=field.name}} =  new {{=getWrapperNameByType(field.type)}}(other._wrapperFields.{{=field.name}});
      {{?}}
      {{~}}
    } else if (typeof other !== 'undefined') {
      this._initMembers();
      translator.constructFromPlanObject(this, other);
    } else {
      this._initMembers();
    }
    this.freeze();
  }

  _initMembers() {
    this._refObject = new {{=refObjectType}}();
    {{~ it.spec.fields :field}}
    {{? it.spec.isEmpty}}
    this._{{=field.name}}Intialized = true;
    {{??}}
    {{? field.type.isPrimitiveType && !field.type.isArray}}
    {{? field.default_value === null}}
    this._{{=field.name}}Intialized = false;
    {{?? field.type.type === 'string' || field.type.type === 'wstring'}}
    this._refObject.{{=field.name}} = "{{=field.default_value.replace(/"/g, '\\"')}}";
    this._{{=field.name}}Intialized = true;
    {{??}}
    this._refObject.{{=field.name}} = {{=field.default_value}};
    this._{{=field.name}}Intialized = true;
    {{?}}
    {{?}}

    {{? field.type.isArray}}
    this._wrapperFields.{{=field.name}} = {{=getWrapperNameByType(field.type)}}.createArray();
    {{? field.default_value !== null && field.type.isPrimitiveType && !isTypedArrayType(field.type)}}
    this._{{=field.name}}Array = {{=JSON.stringify(field.default_value)}};
    {{?}}
    {{? field.default_value !== null && field.type.isPrimitiveType && isTypedArrayType(field.type)}}
    this._wrapperFields.{{=field.name}}.fill({{=getTypedArrayName(field.type)}}.from({{=JSON.stringify(field.default_value)}}));
    {{?}}
    {{?? !field.type.isPrimitiveType || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
    this._wrapperFields.{{=field.name}} = new {{=getWrapperNameByType(field.type)}}();
    {{?? it.spec.msgName === 'String'}}
    primitiveTypes.initString(this._refObject);
    {{?}}
    {{?}}
    {{~}}
  }

  static createFromRefObject(refObject) {
    let self = new {{=objectWrapper}}();
    self.copyRefObject(refObject);
    return self;
  }

  static createArray() {
    return new {{=arrayWrapper}};
  }

  static get ArrayType() {
    return {{=arrayWrapper}};
  }

  static get refObjectArrayType() {
    return {{=refObjectArrayType}}
  }

  static get refObjectType() {
    return {{=refObjectType}};
  }

  toRawROS() {
    this.freeze(true);
    return this._refObject.ref();
  }

  freeze(own = false, checkConsistency = false) {
    if (checkConsistency) {
    {{~ it.spec.fields :field}}
      {{? field.type.isPrimitiveType && !field.type.isArray}}
      if (!this._{{=field.name}}Intialized) {
        throw new TypeError('Invalid argument: {{=field.name}} in {{=it.spec.msgName}}');
      }
      {{?}}
    {{~}}
    }

    {{~ it.spec.fields :field}}
    {{? field.type.isArray && field.type.isPrimitiveType && field.type.isFixedSizeArray}}
    for (let i = 0; i < this._wrapperFields.{{=field.name}}.data.length; i++) {
      this._refObject.{{=field.name}}[i] = this._wrapperFields.{{=field.name}}.data[i];
    }
    {{?? field.type.isArray && field.type.isPrimitiveType && !isTypedArrayType(field.type)}}
    if (!own) {
      this._wrapperFields.{{=field.name}}.fill(this._{{=field.name}}Array);
      this._wrapperFields.{{=field.name}}.freeze(own, checkConsistency);
      this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    } else {
      this._wrapperFields.{{=field.name}}.fill([]);
      this._wrapperFields.{{=field.name}}.freeze(own, checkConsistency);
      this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    }
    {{?? field.type.isArray && !field.type.isPrimitiveType && field.type.isFixedSizeArray}}
    for (let i = 0; i < this._wrapperFields.{{=field.name}}.data.length; i++) {
      this._refObject.{{=field.name}}[i] = this._wrapperFields.{{=field.name}}.data[i].freeze(own, checkConsistency);
      this._refObject.{{=field.name}}[i] = this._wrapperFields.{{=field.name}}.data[i].refObject;
    }
    {{?? !field.type.isPrimitiveType || field.type.isArray}}
    this._wrapperFields.{{=field.name}}.freeze(own, checkConsistency);
    this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    {{? field.type.isArray && field.type.isPrimitiveType }}
    if (own) {
      this._wrapperFields.{{=field.name}}.fill({{=getTypedArrayName(field.type)}}.from([]));
      this._wrapperFields.{{=field.name}}.freeze(own, checkConsistency);
      this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    }
    {{?}}
    {{?? field.type.type === 'string' && it.spec.msgName !== 'String'}}
    if (own) {
      this._wrapperFields.{{=field.name}}.freeze(own, checkConsistency);
    }
    this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    {{?? it.spec.msgName === 'String'}}
    if (own) {
      primitiveTypes.initString(this._refObject.ref(), own);
    }
    {{?}}
    {{~}}
  }

  serialize() {
    this.freeze(false, true);
    return this._refObject.ref();
  }

  deserialize(refObject) {
  {{~ it.spec.fields :field}}
    {{? field.type.isPrimitiveType && !field.type.isArray}}
    this._{{=field.name}}Intialized = true;
    {{?}}

    {{? field.type.isArray && field.type.isPrimitiveType && field.type.isFixedSizeArray}}
    this._refObject.{{=field.name}} = refObject.{{=field.name}};
    this._wrapperFields.{{=field.name}}.fill(refObject.{{=field.name}}.toArray());
    {{?? field.type.isArray && field.type.isPrimitiveType && !isTypedArrayType(field.type)}}
    refObject.{{=field.name}}.data.length = refObject.{{=field.name}}.size;
    for (let index = 0; index < refObject.{{=field.name}}.size; index++) {
      this._{{=field.name}}Array[index] = refObject.{{=field.name}}.data[index].data;
    }
    {{?? field.type.isArray && !field.type.isPrimitiveType && field.type.isFixedSizeArray}}
    this._refObject.{{=field.name}} = refObject.{{=field.name}};
    this._wrapperFields.{{=field.name}}.size = {{=field.type.arraySize}}
    for (let i = 0; i < {{=field.type.arraySize}}; i++) {
      this._wrapperFields.{{=field.name}}.data[i].copyRefObject(refObject.{{=field.name}}[i]);
    }
    {{?? !field.type.isPrimitiveType || field.type.isArray}}
    this._wrapperFields.{{=field.name}}.copyRefObject(refObject.{{=field.name}});
    {{?? field.type.type === 'string' && it.spec.msgName !== 'String'}}
    this._wrapperFields.{{=field.name}}.data = refObject.{{=field.name}}.data;
    {{?? field.type.isPrimitiveType}}
    this._refObject.{{=field.name}} = refObject.{{=field.name}};
    {{?}}
  {{~}}
  }

  toPlainObject(enableTypedArray) {
    return translator.toPlainObject(this, enableTypedArray);
  }

  static freeStruct(refObject) {
  {{~ it.spec.fields :field}}
    {{? field.type.isArray && !field.type.isFixedSizeArray}}
    if (refObject.{{=field.name}}.size != 0) {
      {{=getWrapperNameByType(field.type)}}.ArrayType.freeArray(refObject.{{=field.name}});
      if ({{=getWrapperNameByType(field.type)}}.ArrayType.useTypedArray) {
        // Do nothing, the v8 will take the ownership of the ArrayBuffer used by the typed array.
      } else {
        deallocator.freeStructMember(refObject.{{=field.name}}, {{=getWrapperNameByType(field.type)}}.refObjectArrayType, 'data');
      }
    }
    {{?? field.type.isArray && !field.type.isPrimitiveType && field.type.isFixedSizeArray}}
    for (let i = 0; i < {{=field.type.arraySize}}; i++) {
      {{=getWrapperNameByType(field.type)}}.freeStruct(refObject.{{=field.name}}[i]);
    }
    {{?? !field.type.isPrimitiveType || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
    {{=getWrapperNameByType(field.type)}}.freeStruct(refObject.{{=field.name}});
    {{?? it.spec.msgName === 'String'}}
    deallocator.freeStructMember(refObject, {{=getWrapperNameByType(field.type)}}.refObjectType, '{{=field.name}}');
    {{?}}
  {{~}}
  }

  static destoryRawROS(msg) {
    {{=objectWrapper}}.freeStruct(msg.refObject);
  }

  static type() {
    return {pkgName: '{{=it.messageInfo.pkgName}}', subFolder: '{{=it.messageInfo.subFolder}}', interfaceName: '{{=it.messageInfo.interfaceName}}'};
  }

  static isPrimitive() {
    return {{=isPrimitivePackage(it.spec.baseType)}};
  }

  static get isROSArray() {
    return false;
  }

  get refObject() {
    return this._refObject;
  }

  {{~ it.spec.fields :field}}
  get {{=field.name}}() {
    {{? field.type.isArray && isTypedArrayType(field.type)}}
    return this._wrapperFields['{{=field.name}}'].data;
    {{?? field.type.isArray && field.type.isPrimitiveType}}
    return this._{{=field.name}}Array;
    {{?? field.type.isArray && !field.type.isPrimitiveType}}
    return this._wrapperFields.{{=field.name}};
    {{?? !field.type.isPrimitiveType && !field.type.isArray}}
    return this._wrapperFields.{{=field.name}};
    {{?? !field.type.isArray && field.type.type === 'string' && it.spec.msgName !== 'String'}}
    if (!this._{{=field.name}}Intialized) {
      return undefined;
    }
    return this._wrapperFields.{{=field.name}}.data;
    {{?? true}}
    if (!this._{{=field.name}}Intialized) {
      return undefined;
    }
    return this._refObject.{{=field.name}};
    {{?}}
  }

  set {{=field.name}}(value) {
    {{? field.type.isPrimitiveType && !field.type.isArray}}
    this._{{=field.name}}Intialized = true;
    {{?}}

    {{?field.type.isArray && field.type.isFixedSizeArray}}
    if (value.length !== {{=field.type.arraySize}}) {
      throw new RangeError('The length of the array must be {{=field.type.arraySize}}.');
    }
    {{?}}
    {{?field.type.isArray && field.type.isUpperBound}}
    if (value.length > {{=field.type.arraySize}}) {
      throw new RangeError('The length of array {{=field.name}} must be <= {{=field.type.arraySize}}.');
    }
    {{?}}

    {{? field.type.isArray && isTypedArrayType(field.type)}}
    this._wrapperFields['{{=field.name}}'].fill(value);
    {{?? field.type.isArray && field.type.isPrimitiveType}}
    this._{{=field.name}}Array = value;
    {{?? field.type.isArray && !field.type.isPrimitiveType}}
    this._wrapperFields.{{=field.name}}.fill(value);
    {{?? !field.type.isPrimitiveType && !field.type.isArray}}
    if (value instanceof {{=getWrapperNameByType(field.type)}}) {
      this._wrapperFields.{{=field.name}}.copy(value);
    } else {
      this._wrapperFields.{{=field.name}}.copy(new {{=getWrapperNameByType(field.type)}}(value));
    }
    {{?? !field.type.isArray && field.type.type === 'string' && it.spec.msgName !== 'String'}}
    this._wrapperFields.{{=field.name}}.data = value;
    {{?? true}}
    {{? it.spec.msgName === 'String'}}
    this._refObject.size = Buffer.byteLength(value);
    this._refObject.capacity = Buffer.byteLength(value) + 1;
    {{?}}
    this._refObject.{{=field.name}} = value;
    {{?}}
  }
  {{~}}

  copyRefObject(refObject) {
    this._refObject = new {{=refObjectType}}(refObject.toObject());

    {{~ it.spec.fields :field}}
    {{? field.type.isPrimitiveType && !field.type.isArray}}
    this._{{=field.name}}Intialized = true;
    {{?}}

    {{? field.type.isArray && field.type.isPrimitiveType && !isTypedArrayType(field.type)}}
    refObject.{{=field.name}}.data.length = refObject.{{=field.name}}.size;
    for (let index = 0; index < refObject.{{=field.name}}.size; index++) {
      this._{{=field.name}}Array[index] = refObject.{{=field.name}}.data[index].data;
    }
    {{?? field.type.isArray && field.type.isPrimitiveType && field.type.isFixedSizeArray}}
    this._wrapperFields.{{=field.name}}.fill(refObject.{{=field.name}}.toArray());
    {{?? field.type.isArray && !field.type.isPrimitiveType && field.type.isFixedSizeArray}}
    this._refObject.{{=field.name}} = refObject.{{=field.name}};
    this._wrapperFields.{{=field.name}}.size = {{=field.type.arraySize}}
    for (let i = 0; i < {{=field.type.arraySize}}; i++) {
      this._wrapperFields.{{=field.name}}.data[i].copyRefObject(refObject.{{=field.name}}[i]);
    }
    {{?? !field.type.isPrimitiveType || field.type.isArray || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
    this._wrapperFields.{{=field.name}}.copyRefObject(this._refObject.{{=field.name}});
    {{?}}
    {{~}}
  }

  copy(other) {
    this._refObject = new {{=refObjectType}}(other._refObject.toObject());

    {{~ it.spec.fields :field}}
    {{? field.type.isPrimitiveType && !field.type.isArray}}
    this._{{=field.name}}Intialized = true;
    {{?}}

    {{? field.type.isArray && field.type.isPrimitiveType && !isTypedArrayType(field.type)}}
    this._{{=field.name}}Array = other._{{=field.name}}Array.slice();
    {{?? !field.type.isPrimitiveType || field.type.isArray || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
    this._wrapperFields.{{=field.name}}.copy(other._wrapperFields.{{=field.name}});
    {{?}}
    {{~}}
  }

  static get classType() {
    return {{=objectWrapper}};
  }

  static get ROSMessageDef() {
    return {{=compactMsgDefJSON}};
  }

  hasMember(name) {
    let memberNames = {{=extractMemberNames(it.spec.fields)}};
    return memberNames.indexOf(name) !== -1;
  }
}

// Define the wrapper of array class.
class {{=arrayWrapper}} {
  constructor(size = 0) {
    this._resize(size);
  }

  toRawROS() {
    return this._refObject.ref();
  }

  fill(values) {
    {{? usePlainTypedArray}}
    if (Array.isArray(values)) {
      // Convert JavaScript array
      this._wrappers = new {{=currentTypedArray}}(values);
    } else {
      this._wrappers = values;
    }
    {{?? isPrimitivePackage(it.spec.baseType)}}
    // Now for primitive arrays, only string/bool/int64/uint64 array drops here.
    const length = values.length;
    this._resize(length);
    for (let i = 0; i < length; ++i) {
      let wrapper = new {{=objectWrapper}}();
      wrapper.data = values[i];
      this._wrappers[i] = wrapper;
    }
    {{?? true}}
    const length = values.length;
    this._resize(length);
    values.forEach((value, index) => {
      if (value instanceof {{=objectWrapper}}) {
        this._wrappers[index].copy(value);
      } else {
        this._wrappers[index] = new {{=objectWrapper}}(value);
      }
    });
    {{?}}
  }

  // Put all data currently stored in `this._wrappers` into `this._refObject`
  freeze(own) {
    {{? usePlainTypedArray}}
    // When it's a TypedArray: no need to copy to `this._refArray`
    {{?? true}}
    this._wrappers.forEach((wrapper, index) => {
      wrapper.freeze(own);
      this._refArray[index] = wrapper.refObject;
    });
    {{?}}

    this._refObject.size = this._wrappers.length;
    this._refObject.capacity = this._wrappers.length;

    if (this._refObject.capacity === 0) {
      this._refObject.data = null
    } else {
    {{? usePlainTypedArray}}
    const buffer = Buffer.from(new Uint8Array(this._wrappers.buffer));
    this._refObject.data = buffer;
    {{?? true}}
    this._refObject.data = this._refArray.buffer;
    {{?}}
    }
  }

  get refObject() {
    return this._refObject;
  }

  get data() {
    return this._wrappers;
  }

  get size() {
    return this._wrappers.length;
  }

  set size(value) {
    if (typeof value != 'number') {
      throw new TypeError('Invalid argument: should provide a number to {{=arrayWrapper}}.size setter');
      return;
    }
    return this._resize(value);
  }

  get capacity() {
    return this._wrappers.length;
  }

  set capacity(value) {
    if (typeof value != 'number') {
      throw new TypeError('Invalid argument: should provide a number to {{=arrayWrapper}}.capacity setter');
    }
    return this._resize(value);
  }

  get refObject() {
    return this._refObject;
  }

  _resize(size) {
    if (size < 0) {
      throw new RangeError('Invalid argument: should provide a positive number');
      return;
    }
    {{? usePlainTypedArray}}
    this._refArray = undefined;
    {{?? true}}
    this._refArray = new {{=refArrayType}}(size);
    {{?}}

    this._refObject = new {{=refObjectArrayType}}();
    this._refObject.size = size;
    this._refObject.capacity = size;

    {{? usePlainTypedArray}}
    this._wrappers = new {{=currentTypedArray}}(size);
    {{?? true}}
    this._wrappers = new Array();
    for (let i = 0; i < size; i++) {
      this._wrappers.push(new {{=objectWrapper}}());
    }
    {{?}}
  }

  // Copy all data from `this._refObject` into `this._wrappers`
  copyRefObject(refObject) {
    this._refObject = refObject;

    {{? usePlainTypedArray}}
    const byteLen = refObject.size * ref.types.{{=currentTypedArrayElementType}}.size;
    // An ArrayBuffer object that doesn't hold the ownership of the address
    const arrayBuffer = rclnodejs.createArrayBufferFromAddress(refObject.data, byteLen);
    this._wrappers = new {{=currentTypedArray}}(arrayBuffer);
    {{?? true}}
    let refObjectArray = this._refObject.data;
    refObjectArray.length = this._refObject.size;
    this._resize(this._refObject.size);

    for (let index = 0; index < this._refObject.size; index++) {
      this._wrappers[index].copyRefObject(refObjectArray[index]);
    }
    {{?}}
  }

  copy(other) {
    if (! (other instanceof {{=arrayWrapper}})) {
      throw new TypeError('Invalid argument: should provide "{{=arrayWrapper}}".');
    }

    this._resize(other.size);
    {{? usePlainTypedArray}}
    this._wrappers = other._wrappers.slice();
    {{?? true}}
    // Array deep copy
    other._wrappers.forEach((wrapper, index) => {
      this._wrappers[index].copy(wrapper);
    });
    {{?}}
  }

  static freeArray(refObject) {
    {{? usePlainTypedArray}}
    // For TypedArray: .data will be 'free()'-ed in parent struct
    {{?? true}}
    let refObjectArray = refObject.data;
    refObjectArray.length = refObject.size;
    for (let index = 0; index < refObject.size; index++) {
      {{=objectWrapper}}.freeStruct(refObjectArray[index]);
    }
    {{?}}
  }

  static get elementType() {
    return {{=objectWrapper}};
  }

  static get isROSArray() {
    return true;
  }

  static get useTypedArray() {
    return {{=usePlainTypedArray}};
  }

  get classType() {
    return {{=arrayWrapper}};
  }
}

{{? it.spec.constants != undefined && it.spec.constants.length}}
// Define constants ({{=it.spec.constants.length}} in total)
{{~ it.spec.constants :c}}
{{? c.type === "string"}}
Object.defineProperty({{=objectWrapper}}, "{{=c.name}}", {value: "{{=c.value}}", writable: false, enumerable: true, configurable: true});
{{?? true}}
Object.defineProperty({{=objectWrapper}}, "{{=c.name}}", {value: {{=c.value}}, writable: false, enumerable: true, configurable: true});
{{?}}
{{~}}
{{?}}

module.exports = {{=objectWrapper}};

/*
 * The following is the original spec object coming from parser:
{{=it.json}}
*/
