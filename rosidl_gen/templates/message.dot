// This file is automatically generated by Intel rclnodejs
//
// *** DO NOT EDIT directly
//

'use strict';

const StructType = require('ref-struct');
const ref = require('ref');
const primitiveTypes = require('../rosidl_gen/generator_primitive.js');

{{
var className = it.className;
var generatorName = 'rosidl_generator_nodejs__' + className;

var isStruct = function(type) {
  return !type.isPrimitiveType && !type.isArray;
};

var isStructArray = function(type) {
  return !type.isPrimitiveType && type.isArray;
};

var isPrimitiveArray = function(type) {
  return type.isPrimitiveType && type.isArray;
};

var shouldRequireType = function(type) {
  return !type.isPrimitiveType;
};

var isPrimitive = function(type) {
  return type.isPrimitiveType && !type.isArray;
};

var isString = function(type) {
  return type.type === 'string' && !type.isArray;
};

var calcStructTypeName = function(type) {
  return type.pkgName + '__msg__' + type.type;
};

var calcFileNameFromType = function(type) {
  return calcStructTypeName(type) + '.js';
};

var calcGeneratorTypeNameFromType = function(type) {
  return "rosidl_generator_nodejs__" + type.pkgName + '__msg__' + type.type;
};

}}
// TODO: remove duplicated (if any)
{{~ it.spec.fields :field}}
{{? shouldRequireType(field.type)}}
var {{=calcStructTypeName(field.type)}} = require('../generated/{{=calcFileNameFromType(field.type)}}');
{{?}}
{{~}}

//
// Define the struct type
//
const {{=generatorName}} = StructType({
{{~ it.spec.fields :field}}

{{? isPrimitive(field.type)}}
  {{=field.name}}: primitiveTypes.{{=field.type.type}},
{{?? isPrimitiveArray(field.type)}}
  {{=field.name}}: primitiveTypes.{{=field.type.type}}, // TODO(Kenny): it's actually an array, need to generate a primitive type array
{{?? isStructArray(field.type)}}
  {{=field.name}}: {{=calcStructTypeName(field.type)}}.RawStructType, // TODO(Kenny): it's actually an array, need to generate a struct type array
{{?? true}}
  {{=field.name}}: {{=calcStructTypeName(field.type)}}.RawStructType,
{{?}}

{{~}}
});


//
// Define the wrapper class
//
class {{=className}} {
  constructor(other) {
    let otherObj = undefined;
    if (typeof other === 'object' && other.__ref_message) {
      otherObj = other.__ref_message.toObject();
    }
    this.__ref_message = new {{=generatorName}}(otherObj);
    this.__ref_object = {};
  }

{{~ it.spec.fields :field}}
  get {{=field.name}}() {
  {{? isString(field.type)}}
    return this.__ref_message.{{=field.name}}.data;
  {{?? isStruct(field.type)}}
    if (!this.__ref_object['{{=field.name}}']) {
      this.__ref_object['{{=field.name}}'] = new {{=calcStructTypeName(field.type)}}();
      this.__ref_object['{{=field.name}}'].__ref_message = this.__ref_message.{{=field.name}};
    }
    return this.__ref_object.{{=field.name}};
  {{?? true}}
    return this.__ref_message.{{=field.name}};
  {{?}}
  }

  set {{=field.name}}(value) {
  {{? isString(field.type)}}
    {{var handleName = '__handle_' + field.name;}}
    if (this.__ref_message.{{=handleName}}) {
      // console.log('    Dismiss the previoud handle:', this.__ref_message.{{=handleName}});
      this.__ref_message.{{=handleName}}.dismiss();
    }
    this.__ref_message.{{=handleName}} = primitiveTypes.stringAssignFunc(this.__ref_message.{{=field.name}}.ref(), value);
  {{?? true}}
    this.__ref_message.{{=field.name}} = value;
  {{?}}
  }
{{~}}

  copy(other) {
    this.__ref_message = new {{=generatorName}}(other.__ref_message.toObject());
  }

}

{{? it.spec.constants != undefined && it.spec.constants.length}}
//
// Define constants ({{=it.spec.constants.length}} in total)
//
{{~ it.spec.constants :c}}
Object.defineProperty({{=className}}, "{{=c.name}}", {value: {{=c.value}}, writable: false, enumerable: true, configurable: true});
{{~}}
{{?}}
// Raw type and wrapper type
{{=className}}.RawStructType = {{=generatorName}};
{{=generatorName}}.WrapperType = {{=className}};
// Expose internal buffer
{{=className}}.getRefBuffer = function(msg) {
  return msg.__ref_message.ref();
};

//
// Array Type for type: {{=className}}
//
{{=className}}.ArrayType = {}; // TODO(Kenny): define class {{=className}}Array type
module.exports = {{=className}};

/*
 * The following is the original spec object coming from parser:

{{=it.json}}

*/
