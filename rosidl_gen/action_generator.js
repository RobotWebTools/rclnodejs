// Copyright (c) 2018 Intel Corporation. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

'use strict';

const dot = require('dot');
const fse = require('fs-extra');
const path = require('path');

dot.templateSettings.strip = false;
dot.log = process.env.RCLNODEJS_LOG_VERBOSE || false;
const dots = dot.process({path: path.join(__dirname, '../rosidl_gen/templates')});

async function generateIDLFromAction(action) {
  const header = '# This file is automatically generated by rosidl-generator\n';
  let data = await fse.readFile(action.filePath, 'utf8');
  let sections = extractMessageSectionsFromAction(data);
  let dir = path.join(path.parse(action.filePath).dir, 'msg');
  let generatedInterfaces = [];

  await fse.mkdirs(dir);
  await fse.writeFile(path.join(dir, `${action.interfaceName}Result.msg`),
    header + sections.result, 'utf8');
  generatedInterfaces.push(`${action.interfaceName}Result`);
  await fse.writeFile(path.join(dir, `${action.interfaceName}Goal.msg`),
    header + sections.goal, 'utf8');
  generatedInterfaces.push(`${action.interfaceName}Goal`);
  await fse.writeFile(path.join(dir, `${action.interfaceName}Feedback.msg`),
    header + sections.feedback, 'utf8');
  generatedInterfaces.push(`${action.interfaceName}Feedback`);
  await fse.writeFile(path.join(dir, `${action.interfaceName}Action.msg`),
    header + generateActionMessage(action), 'utf8');
  generatedInterfaces.push(`${action.interfaceName}Action`);
  await fse.writeFile(path.join(dir, `${action.interfaceName}ActionFeedback.msg`),
    header + generateActionFeedbackMessage(action), 'utf8');
  generatedInterfaces.push(`${action.interfaceName}ActionFeedback`);
  await fse.writeFile(path.join(dir, `${action.interfaceName}ActionGoal.msg`),
    header + generateActionGoalMessage(action), 'utf8');
  generatedInterfaces.push(`${action.interfaceName}ActionGoal`);
  await fse.writeFile(path.join(dir, `${action.interfaceName}ActionResult.msg`),
    header + generateActionResultMessage(action), 'utf8');
  generatedInterfaces.push(`${action.interfaceName}ActionResult`);

  let cmakeFile = dots.CMakeLists({
    projectName: action.pkgName,
    msgFiles: generatedInterfaces,
    dependencies: extractDependencies(data)
  });
  let packageFile = dots.package({projectName: action.pkgName});

  await fse.writeFile(path.join(path.parse(action.filePath).dir, 'CMakeLists.txt'),
    cmakeFile,
    'utf8');
  await fse.writeFile(path.join(path.parse(action.filePath).dir, 'package.xml'),
    packageFile,
    'utf8');
  return {generatedInterfaces, dir};
}

function extractDependencies(file) {
  let dependencies = [];
  let lines = file.split(/\r?\n/);
  lines.forEach(line => {
    let splits = line.split('/');
    if (splits.length > 1) {
      dependencies.push(splits[0]);
    }
  });
  return dependencies;
}

function extractMessageSectionsFromAction(file) {
  let [goal, result, feedback] = file.split('---').map((line) => line.trim());
  return {goal, result, feedback};
}

function generateActionMessage(action) {
  return `${action.interfaceName}ActionGoal action_goal\n` +
         `${action.interfaceName}ActionResult action_result\n` +
         `${action.interfaceName}ActionFeedback action_feedback`;
}

function generateActionFeedbackMessage(action) {
  return 'std_msgs/Header header\n' +
         'actionlib_msgs/GoalStatus status\n' +
         `${action.interfaceName}Feedback feedback`;
}

function generateActionGoalMessage(action) {
  return 'std_msgs/Header header\n' +
         'actionlib_msgs/GoalID goal_id\n' +
         `${action.interfaceName}Goal goal`;
}

function generateActionResultMessage(action) {
  return 'std_msgs/Header header\n' +
         'actionlib_msgs/GoalStatus status\n' +
         `${action.interfaceName}Result result`;
}

module.exports = generateIDLFromAction;
